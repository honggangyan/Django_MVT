# Docker Compose Configuration File

# Version of the Docker Compose file format
version: "3.8"

# Services define the containers that will be run
services:
  # Database service
  db:
    image: postgres:13  # Uses PostgreSQL version 13
    environment:
      - POSTGRES_DB=postgres  # Sets the name of the default database
      - POSTGRES_USER=postgres  # Sets the default username
      - POSTGRES_PASSWORD=password  # Sets the password for the default user (should be changed in production)
    volumes:
      - postgres_data:/var/lib/postgresql/data  # Persists database data across container restarts

  # Web application service
  web:
    build: .  # Builds the image using the Dockerfile in the current directory
    volumes:
      - .:/app  # Mounts the current directory to /app in the container for live code changes
    ports:
      - "8000:8000"  # Maps port 8000 on the host to port 8000 in the container
    # Consider adding a depends_on section to ensure the web service starts after the db service
    # This would look like:
    # depends_on:
    #   - db

# Volumes allow data to persist between container restarts
volumes:
  postgres_data:  # Named volume for persisting PostgreSQL data

# How Docker Compose works:
# 1. It reads this YAML file to understand the desired state of your multi-container application.
# 2. It creates a Docker network for the services to communicate.
# 3. It builds or pulls the necessary images for each service.
# 4. It starts the containers in the order specified (considering dependencies).
# 5. It sets up volumes, environment variables, and port mappings as defined.
# 6. It allows for easy scaling, updating, and managing of the entire application stack.
# 7. With a single command (docker-compose up), it can start all services defined here.
